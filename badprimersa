#!/usr/bin/python3

#
# Code written by Sarah Hickey, Cynthia Wang, and Nikol Kovacevic for CS340 Spring 2024. This is the buggy version that does *not* test for primality.
# Last edited 8 May 2024
#

import sys
from math import gcd 
import random
from egcd import egcd # for finding inverse 
from sympy import isprime # use this for primality testing

def generate_public(phi_n):
    """
        On the input of phi_n, generate_public finds and returns some number e that is relatively prime to phi_n to act as a public key
        for our encryption scheme. Note that we randomly choose an integer from the range 2 to phi_n, as randint is inclusive of the first
        parameter and returning the value 1 would result in no actual encryption taking place. 
    """
    # initialize variable to keep track of status of a potential e
    relative_prime = False
    
    while not relative_prime:
        e = random.randint(2, phi_n) # randomly choose a number in between 2 and phi of n (we don't want to choose 1, that doesn't encrypt)
        if gcd(e, phi_n) == 1:
            relative_prime = True # we've found a possible eâ€”continue
    return e
    
    
def phi(p):
    """
        On the input of some prime p, phi(p) will return the result of Euler's Phi function (the size of the set of numbers relatively prime
        to p). Note that it is imperative that p is a prime number, as otherwise this will not return the correct result.
    """
    return p-1

def encrypt(plaintext, e, mod):
    """
        On the input of some plaintext string, an integer to represent the key, and an integer to represent the mod pq, encrypt() encrypts 
        each character by raising its Unicode value to the power of e mod pq. We store these Unicode values in an array. 
         
        We referened the following resources to complete this: 
        https://docs.python.org/3/library/functions.html#pow for the pow() function
        
        https://docs.python.org/3/library/functions.html#ord for extracting Unicode values. 
    """
    cipher = [pow(ord(letter), e, mod) for letter in plaintext]
    return cipher 

def retrieve_private_key(phi, key):
    """
        On the inputs of integers phi and key, retrieve_public_key finds the inverse of key in mod phi by using an implmentation of 
        Euclid's Extended Algorithm from the egcd library (see here https://pypi.org/project/egcd/). Ultimately, the private_key
        is some integer d such that de is congruent to 1 mod phi. This function always returns the positive representation of this number.
    """
    tuple = egcd(key, phi)
    private_key = tuple[1] # grab second value
    if private_key < 0: # case where private key is negative (we want positive only!) 
        private_key += phi
    return private_key
    
    
def decrypt(cipher, d, mod):
    """
        On the input of a array of Unicode values, the integer d, and the integer mod, decrypt() effectively decrypts each character 
        by raising it to the power of d mod "mod" and then converting it to its corresponding Unicode character using the value.
        
        Resources visited: https://docs.python.org/3/library/functions.html#chr for a refresher on Unicode value/character conversions.
        
    """
    plainvals = [chr(pow(val, d, mod))for val in cipher]
    return plainvals

def rsa(p, q, plaintext):
    """
        On the inputs of two primes p, q and a string plaintext, rsa encrypts this message using a randomly selected public_key, then decrypts it 
        using a private_key generated by a version of Euclid's Extended algorithm. It returns nothing but sends the decrypted version to stdout. 
    """
    n = p*q # first find product
    phi_n = phi(p) * phi(q) #find phi(n)
    
    # encrypt
    public_key = generate_public(phi_n)
    cipher = encrypt(plaintext, public_key, n)
    
    # decrypt
    private_key = retrieve_private_key(phi_n, public_key)
    plain = decrypt(cipher, private_key, n)
    
    # result
    print("This is your original message: ", ''.join(plain)) 
    
    

def main():
    # read input from std in
    # we expect input to have this order: p1 p2 plaintext (with one space in between them) when run from command line
    
    if len(sys.argv) != 4:
        print("Please use format: ./rsa prime1 prime2 'plaintext goes here' separated by spaces.")
        
    else:
        
        # first check that inputs are correct
        p1 = int(sys.argv[1])
        p2 = int(sys.argv[2])
        plaintext = sys.argv[3]
        
        if isprime(p1) and isprime(p2):
            rsa(p1, p2, plaintext)
        exit(0)
            
if __name__ == "__main__":
    main()
