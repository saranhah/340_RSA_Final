#!/usr/bin/python3
import sys
from math import gcd 


def primality_test(p):
    """
        This function will eventually implemented to run the some sort of primality test on the two primes provided. It will return False if it is definitive
        that p is a composite number. It will return True if it passes the test, but it is important to note that this does not necessarily
        mean that p is prime (it could be a Carmichael number).
        
        From Wikipedia page on AKS: https://en.wikipedia.org/wiki/AKS_primality_test 
        Input: integer n > 1.
            Check if n is a perfect power: if n = ab for integers a > 1 and b > 1, then output composite.
            Find the smallest r such that ordr(n) > (log2 n)2. If r and n are not coprime, then output composite.
        For all 2 ‚â§ a ‚â§ min (r, n‚àí1), check that a does not divide n: If a|n for some 2 ‚â§ a ‚â§ min (r, n‚àí1), then output composite.
        If n ‚â§ r, then output prime.
        For a = 1 to ‚åäùúë(ùëü)log2(ùëõ) do
            if (X+a)n ‚â† Xn+a (mod Xr ‚àí 1,n), then output composite;
        Output prime.

    """
    pass
def generate_public(p, q):
    return p*q
def unknown_phi(n):
    """ Referenced this StackOverflow post to write this code: https://stackoverflow.com/questions/18114138/computing-eulers-totient-function"""
    # this is the slow way where ew don't actually know if n is prime
    
def phi(p):
    # this uses the number theory principle and requires both p and q to be prime. This is *sort of* cheating. there's a much slower way 
    # to calculate this using the gcd function from the math library.
    return p-1
def encrypt(plaintext, key):
    cipher = ""
    for letter in plaintext:
        print("this is the letter: ", letter)
        cipher += chr((ord(letter)**key) % 127)
        print("this is cipher atp: ", cipher)
    return cipher
def retrieve_private_key(p, q):
    pass
def decrypt(cipher, key):
    pass

def rsa(p, q, plaintext):
    #primality_test(p, q) implement this later!
    public_key = generate_public(p, q)
    cipher = encrypt(plaintext, public_key)
    print("This is your encrypted message: ", cipher)
    #private_key = retrieve_private_key(p, q)
    #plain = decrypt(cipher, private_key)
    #print("This is your original message: ", plain)

#TODO: 
# 1. Implement basic RSA using user input for primes (foundation implementation) 
# 2. set this up with PBT/have PBT generate primes. first assume that all inputs are prime numbers. 
#    (oracle should at this point just be checking that the decrypted message is the same as the plaintext that's been passed in)
# 3. find way for RSA to "check" for primes (using the miller-rabin test maybe)
# 4. Update Oracle to also generate non-prime numbers to input into RSA. we want RSA to reject non-prime numbers in *most* cases
# 5. Then update RSA to include digital signatures
# 6. Alloy model (ask Alexa about what kind of Alloy model this should be)

def main():
    # read input from std in
    # we expect input to have this order: p1 p2 plaintext (with one space in between them) when run from command line
    if len(sys.argv) != 4:
        print("Please use format: ./rsa prime1 prime2 'plaintext goes here' separated by spaces.")
    else:
        p1 = int(sys.argv[1])
        p2 = int(sys.argv[2])
        plaintext = sys.argv[3]
        
        return rsa(p1, p2, plaintext)
if __name__ == "__main__":
    main()